/******************************************************************************
Developed by QuyNguyen-GlassEgg:
	- File structure from 3dsMax's StandardFX11.fx

    - PBR Algorithm from UE4
	- IBL Diffuse/Specular Cubemaps created by IBL Baker (Cubemaps from CmftStudio cannot load into 3DS Max (because of INCORRECT HEADER ???)
		+ SpecularCube Resolution is 256x256; 32 bits
		+ DiffuseCube Resolution is 64x64; 32 bits

******************************************************************************/

string ParamID = "0x003";

float Script : STANDARDSGLOBAL <
    string UIWidget = "none";
    string ScriptClass = "object";
    string ScriptOrder = "standard";
    string ScriptOutput = "color";
    string Script = "Technique=Main;";
> = 0.8;

/////////////////// Part I.     UN-TWEAKABLES - AUTOMATICALLY-TRACKED TRANSFORMS ////////////////

float4x4 WorldITXf : WorldInverseTranspose < string UIWidget="None"; >;
float4x4 WvpXf : WorldViewProjection < string UIWidget="None"; >;
float4x4 WorldXf : World < string UIWidget="None"; >;
float4x4 ViewIXf : ViewInverse < string UIWidget="None"; >;


/////////////////// Part II.     CONSTANTS - INCLUDE ////////////////
#define _3DSMAX_SPIN_MAX 99999
#define NumberOfMipMaps 0

#define PI 3.1415926f
#define INV_PI 0.31830989f

#define GAMMA 2.2f
#define INV_GAMMA 0.454545f

#define EPSILON 10e-5f
#define ROUGHNESS_BIAS 0.005f

// IBL Cubemaps generated by IBLBaker;
// SpecularCube Resolution is 256x256; 32 bits
// DiffuseCube Resolution is 64x64; 32 bits
#define PMREM_CUBE_MAP_SIZE 256.0f
#define PMREM_MIP_COUNT 7.0f

// iRacing use UV Channel 2 for Occlusion
#define _USE_MAP_2_CHANNEL_

/////////////////// Part III.     ASSIGN VERTEX'S INFO TO REGISTERS (TEXCOORD0 - TEXCOORDn) ////////////////

// Map 1 is always used
int texcoord0 : Texcoord
<
	int Texcoord = 0;  // Register TEXCOORD0
	int MapChannel = 1; // Map Channel 1
	string UIWidget = "None";
>;

#ifdef _USE_MAP_2_CHANNEL_
int texcoord1 : Texcoord
<
	int Texcoord = 1;  // Register TEXCOORD1
	int MapChannel = 2; // Map Channel 2
	string UIWidget = "None";
>;
#endif

#ifdef _USE_MAP_3_CHANNEL_
int texcoord2 : Texcoord
<
	int Texcoord = 2;  // Register TEXCOORD2
	int MapChannel = 3; // Map Channel 3
	string UIWidget = "None";
>;
#endif


/////////////////// Part IV.    TWEAKABLE PARAMETERS - COLORS - TEXTURES ////////////////////

////-------------- Part IV.1. Attributes

// ------- Normal Map Controls: BumpScale + FlipGreen
float g_NormalMapBumpScale <
	string UIName = "Normal Map - Normal Height";
	string UIWidget = "slider";
	float UIMin = 0.0f;
	float UIMax = 10.0f;
	float UIStep = 0.01f;
>   = 1.0f;
bool g_NormalMapFlipGreen <
	string UIName = "Normal Map - Flip Green";
> = false;
bool g_NormalMapDisable <
	string UIName = "Normal Map - Disable";
> = false;


// ------- Checker Controls: TilingU + TilingV + UVChannel
float g_CheckerTilingU <
	string UIName = "Checker - U Tiling";
	string UIWidget = "slider";
	float UIMin = 0.01f;
	float UIMax = 50.0f;
	float UIStep = 0.01f;
>   = 1.0f;
float g_CheckerTilingV <
	string UIName = "Checker - V Tiling";
	string UIWidget = "slider";
	float UIMin = 0.01f;
	float UIMax = 50.0f;
	float UIStep = 0.01f;
>   = 1.0f;
int g_CheckerUVChannel <
	string UIName = "Checker - UV Channel";
	string UIWidget = "slider";
	float UIMin = 0;	
	float UIMax = 2;	
>  = 0;

// ------- IBL (Env) Controls
float g_IblEnvRotation <
	string UIName = "IBL Env Rotation";
	string UIWidget = "slider";
	float UIMin = 0.0f;
	float UIMax = 360.0f;
	float UIStep = 0.5f;
>   = 0.0f;

// ------- IBL Scale
float g_IblSpecScale <
	string UIName = "IBL Spec Scale";
	string UIWidget = "slider";
	float UIMin = 0.0f;
	float UIMax = 5.0f;
	float UIStep = 0.01f;
>   = 1.0f;
float g_IblDiffScale <
	string UIName = "IBL Diff Scale";
	string UIWidget = "slider";
	float UIMin = 0.0f;
	float UIMax = 5.0f;
	float UIStep = 0.01f;
>   = 1.0f;

// ------- Exposure
float g_SceneExposure <
	string UIName = "Scene Exposure Exponent";
	string UIWidget = "slider";
	float UIMin = 0.0f;
	float UIMax = 10.0f;
	float UIStep = 0.01f;
>   = 0.0f;


// ------- ToneMapping Method
int g_SceneToneMappingMethod <
	string UIName = "Scene ToneMapping";
	string UIWidget = "slider";
	float UIMin = 1;	
	float UIMax = 3;	
>  = 1;


// ------- Debug Mode
int g_SceneDebugMode <
	string UIName = "Scene Debug Mode";
	string UIWidget = "slider";
	float UIMin = 0;	
	float UIMax = 50;	
>  = 0;

// ------- Debug Mode plus: Discard Rendering
bool g_DiscardRendering <
	string UIName = "Discard Rendering";
> = false;


////------------- Part IV.2. Textures

// Albedo Map
Texture2D g_AlbedoTexture < 
	string UIName = "Albedo Map";
	string ResourceType = "2D";
>;
// Normal Map
Texture2D g_NormalTexture < 
	string UIName = "Normal Map";
	string ResourceType = "2D";
>;
// Surface Map
Texture2D g_SurfaceTexture < 
	string UIName = "Surface Map";
	string ResourceType = "2D";
>;
// Occlusion Map
Texture2D g_OcclusionTexture < 
	string UIName = "Occlusion Map";
	string ResourceType = "2D";
>;

#ifdef _NEED_EMISSIVE_MAP_
	// Emissive Map
	Texture2D g_EmissiveTexture < 
		string UIName = "Emissive Map";
		string ResourceType = "2D";
	>;
#endif
#ifdef _NEED_DECAL_MAP_
	// Decal Map - UV 3
	Texture2D g_DecalTexture < 
		string UIName = "Decal Map - UV3";
		string ResourceType = "2D";
	>;
#endif

// IBL Cubemaps
TextureCube g_IblSpecTexture < 
	string UIName = "IBL Spec";
	string ResourceType = "CUBE";
>;

TextureCube g_IblDiffTexture < 
	string UIName = "IBL Diff";
	string ResourceType = "CUBE";
>;

Texture2D g_IblBrdfTexture < 
	string UIName = "IBL Brdf";
	string ResourceType = "2D";
>;

// Checker Texture
Texture2D g_CheckerTexture < 
	string UIName = "Checker Map";
	string ResourceType = "2D";
>;


////------------- Part IV.3. SamplerState
// +++ Texture2D  Sampler
SamplerState SamplerAnisoWrap
{
	Filter = ANISOTROPIC;
	AddressU = Wrap;
	AddressV = Wrap;
};

// + CubeMapSampler
SamplerState CubeMapSampler
{
	Filter = ANISOTROPIC;
	AddressU = Clamp;
	AddressV = Clamp;
	AddressW = Clamp;    
};



/////////////////// Part V.     DEFINE STRUCTS FOR VERTEX SHADER AND PIXEL SHADER ////////////////////

/* data from application vertex buffer */
struct appdata {
	float4 Position		: POSITION;
	float3 Normal		: NORMAL;
	float3 Tangent		: TANGENT;
	float3 Binormal		: BINORMAL;

	float2 UV0		: TEXCOORD0;

	#ifdef _USE_MAP_2_CHANNEL_
		float2 UV1		: TEXCOORD1;
	#endif

	#ifdef _USE_MAP_3_CHANNEL_
		float2 UV2		: TEXCOORD2;
	#endif

	// More Channel
	#ifdef _USE_VERT_COLOR_CHANNEL_
		float3 Color		: TEXCOORD3;
	#endif

	#ifdef _USE_VERT_ILLUM_CHANNEL_
		float3 Illum		: TEXCOORD4;
	#endif

	#ifdef _USE_VERT_ALPHA_CHANNEL_
		float3 Alpha		: TEXCOORD2;
	#endif
};

/* data passed from vertex shader to pixel shader */
struct vertexOutput {
    float4 HPosition	: SV_Position;

    float4 UV0		: TEXCOORD0;
	#ifdef _USE_MAP_2_CHANNEL_
		float4 UV1		: TEXCOORD6;
	#endif
	#ifdef _USE_MAP_3_CHANNEL_
		float4 UV2		: TEXCOORD7;
	#endif

	#ifdef _USE_VERT_COLOR_CHANNEL_
		float3 Color		: TEXCOORD1;
	#endif

    // The following values are passed in "World" coordinates since
    //   it tends to be the most flexible and easy for handling
    //   reflections, sky lighting, and other "global" effects.
    float3 WorldNormal	: TEXCOORD2;
    float3 WorldTangent	: TEXCOORD3;
    float3 WorldBinormal : TEXCOORD4;
    float3 WorldView	: TEXCOORD5;
	
	float4 wPos		: TEXCOORD8;
};



/////////////////// Part VI.     VERTEX SHADING ////////////////////

/*********** Generic Vertex Shader ******/

vertexOutput std_VS(appdata IN) {
    vertexOutput OUT = (vertexOutput)0;
    OUT.WorldNormal = mul(IN.Normal,WorldITXf).xyz;
    OUT.WorldTangent = mul(IN.Tangent,WorldITXf).xyz;
    OUT.WorldBinormal = mul(IN.Binormal,WorldITXf).xyz;
    float4 Po = float4(IN.Position.xyz,1);
    float3 Pw = mul(Po,WorldXf).xyz;
    OUT.WorldView = normalize(ViewIXf[3].xyz - Pw);
    OUT.HPosition = mul(Po,WvpXf);
	OUT.wPos = mul(IN.Position, WorldXf);
	
	OUT.UV0.xy = IN.UV0.xy;

	#ifdef _USE_MAP_2_CHANNEL_
   		OUT.UV1.xy = IN.UV1.xy;
	#endif
	#ifdef _USE_MAP_3_CHANNEL_
   		OUT.UV2.xy = IN.UV2.xy;
	#endif

	#ifdef _USE_VERT_COLOR_CHANNEL_
		out.Color = IN.Color;
	#endif

    return OUT;
}



/////////////////// Part VII.     UTILITY FUNCTIONS ////////////////////

float2 float2_splat(float _x) { return float2(_x, _x); }
float3 float3_splat(float _x) { return float3(_x, _x, _x); }
float4 float4_splat(float _x) { return float4(_x, _x, _x, _x); }

float3 vectorToColor(float3 _v)
{
	float3 outCol = 0.5 + 0.5 * _v;
	
	return outCol;
}

float3 toLinear(float3 _rgb)
{
	return pow(_rgb, GAMMA);
}

float3 toGamma(float3 _rgb)
{
	return pow(_rgb, INV_GAMMA);
}

float3 uncharted2_ToneMapping(float3 x)
{	// x is a hdrColor
	float A = 0.15f;
	float B = 0.50f;
	float C = 0.10f;
	float D = 0.20f;
	float E = 0.02f;
	float F = 0.30f;
	
	return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

float3 uncharted2Filmic_ToneMapping(float3 hdrColor)
{
	float ExposureBias = 2.0f;
	float3 curr = uncharted2_ToneMapping( ExposureBias * hdrColor);

	float W = 11.2f;
	float3 whiteScale = 1.0f / uncharted2_ToneMapping(W);
	float3 color = curr * whiteScale;
		
	float3 retColor = toGamma(color);
	return retColor.rgb;
}

float3 filmic_ToneMapping(float3 input) //John Hable's filmic tonemap function with fixed values
{
	float A = 0.22;
	float B = 0.3;
	float C = 0.1;
	float D = 0.2;
	float E = 0.01;
	float F = 0.3;
	float linearWhite = 11.2;

	float3 Fcolor = ((input*(A*input+C*B)+D*E)/(input*(A*input+B)+D*F)) - E/F;
	float  Fwhite = ((linearWhite*(A*linearWhite+C*B)+D*E)/(linearWhite*(A*linearWhite+B)+D*F)) - E/F;
	return Fcolor/Fwhite;
}

float3 rotateVectorYaw(float3 vec, float degreeOfRotation)
{
	float3 rotatedVec = vec;
	float angle = radians(degreeOfRotation);

	rotatedVec.x = ( cos(angle) * vec.x ) - ( sin(angle) * vec.z );
	rotatedVec.z = ( sin(angle) * vec.x ) + ( cos(angle) * vec.z );	

	return rotatedVec;
}

float3 calculateWorldNormalFromNormalTexture(float3 normalTex, bool flipGreen, float bumpScale, float3 worldNormal, float3 worldTangent, float3 worldBiNormal, bool orthogonalizeTangentBitangentPerPixel=false)
{
	
	float3 bump = 2.0f * (normalTex - 0.5f);

	// Flip green value because by default green means -y in the normal map generated by 3ds Max.
	bump.g = -bump.g;

	if (flipGreen)
	{
		bump.g = -bump.g;
	}
	
	if (orthogonalizeTangentBitangentPerPixel)
	{
		float3 bitangent = normalize(cross(worldNormal, worldTangent));
		worldTangent = normalize(cross(bitangent, worldNormal));
		// Bitangent need to be flipped if the map face is flipped. We don't have map face handedness in shader so make
		// the calculated bitangent point in the same direction as the interpolated bitangent which has considered the flip.
		worldBiNormal = sign(dot(bitangent, worldBiNormal)) * bitangent;
	}

	float3 worldNormalWithTexture = bumpScale * (bump.x * worldTangent + bump.y * worldBiNormal) + bump.z * worldNormal;
	worldNormalWithTexture = normalize(worldNormalWithTexture);

	return worldNormalWithTexture;
}


/////////////////// Part VIII.     PIXEL SHADING ////////////////////
// this struct hold the fragment state for calculating or debugging
struct	FragmentState
{
	// inputs from vertex shader (in world space)
	float3	vertexNormal; // in world space
	float3	vertexTangent; // in world space
	float3	vertexBinormal; // in world space
	
	// raw values from Texture Samplers.
	float3 inAlbedo; // sRGB space
	float  inAlbedoAlpha;
	float3 inNormal;
	float3 inEmissive; // sRGB space
	float  inOcclusion;
	float  inRoughness;
	float  inMetalness;
	
	// values for PBR-Metalness calculating.
	float3 matAlbedo; // linear Space
	float3 matNormal; // world space with texture map applied
	float3 matSpecColor;  // linear Space
	float  matRoughness;
	float3 matEmissive; // linear Space
	float  matOcclusion;
	float  matOpacity;

	// Environment light.
	float3 inDiffuseEnv;
	float3 inSpecularEnv;

	float3 iblDiffuse;
	float3 iblSpecular;
};

float4 std_PS(vertexOutput IN) : SV_Target {
	//------------ Discard rendering ------------
	if (g_DiscardRendering) discard;

	// #ifdef _LIGHT_GLASS_
	// 	if (g_DiscardRendering_LightGlasses) discard;
	// #endif
	// #ifdef _WINDOWS_
	// 	if (g_DiscardRendering_Windows) discard;
	// #endif
	// #ifdef _EXT_PARTS_
	// 	if (g_DiscardRendering_ExtParts) discard;
	// #endif
	// #ifdef _EXT_INT_GENERIC_
	// 	if (g_DiscardRendering_Generic) discard;
	// #endif

	



	//-------------- Rendering + Debugging -------------

	// Fragment State variable
	FragmentState state;

	// ---------- Normalize WorldSpace Vectors
	float3 WorldView = normalize(IN.WorldView);
    float3 WorldNormal = normalize(IN.WorldNormal);
    float3 WorldTangent = normalize(IN.WorldTangent);
    float3 WorldBinormal = normalize(IN.WorldBinormal);

	// ---------- Get UVs
	float2 UV0, UV1, UV2;
	UV0 = IN.UV0.xy;
	UV1 = UV2 = UV0;

	#ifdef _USE_MAP_2_CHANNEL_
		UV1 = IN.UV1.xy;
	#endif
	#ifdef _USE_MAP_3_CHANNEL_
		UV2 = IN.UV2.xy;
	#endif

	// ------------ Get Textures
	float4 albedoTex = g_AlbedoTexture.Sample(SamplerAnisoWrap, UV0);
	float3 normalTex = g_NormalTexture.Sample(SamplerAnisoWrap, UV0).xyz;
	float3 surfaceTex = g_SurfaceTexture.Sample(SamplerAnisoWrap, UV0).xyz;

	float  occlusionTex = g_OcclusionTexture.Sample(SamplerAnisoWrap, UV1).xyz; // iRacing use Map Channel 2 for Occlusion

    #ifdef _NEED_DECAL_MAP_
        float4 decalTex_UV3 = g_DecalTexture.Sample(SamplerAnisoWrap, UV2);
        albedoTex.rgb = lerp(albedoTex.rgb, decalTex_UV3.rgb, decalTex_UV3.a);
    #endif

	// store inputs
	state.vertexNormal = WorldNormal;
	state.vertexTangent = WorldTangent;
	state.vertexBinormal = WorldBinormal;

	state.inAlbedo = albedoTex.rgb; // sRGB space
	state.inNormal = normalTex;
	state.inOcclusion = occlusionTex;
	state.inRoughness = surfaceTex.g;
	state.inMetalness = surfaceTex.r;
	#ifdef _USE_ALBEDO_ALPHA_FOR_TRANSPARENCY_
		state.inAlbedoAlpha = albedoTex.a;
	#else
		state.inAlbedoAlpha = 1.0f;
	#endif
	
	#ifdef _NEED_EMISSIVE_MAP_
		state.inEmissive = g_EmissiveTexture.Sample(SamplerAnisoWrap, UV0).xyz; // sRGB space
	#else
		state.inEmissive = float3_splat(0.0);
	#endif

	// Calculate PBR material values
	float3 baseColor_InLinear = toLinear(albedoTex.rgb);

	float3 worldNormalWithTexture = calculateWorldNormalFromNormalTexture(normalTex, g_NormalMapFlipGreen, g_NormalMapBumpScale, WorldNormal, WorldTangent, WorldBinormal, false); // world normal with texture
	// Enable/Disable normalMap
	if (g_NormalMapDisable)
		worldNormalWithTexture = state.vertexNormal;

	state.matNormal = worldNormalWithTexture;
	state.matAlbedo = lerp(baseColor_InLinear, 0.0f, state.inMetalness); // linear Space
	state.matSpecColor = lerp(0.04, baseColor_InLinear, state.inMetalness);  // linear Space
	state.matRoughness = state.inRoughness * (1.0f - ROUGHNESS_BIAS) + ROUGHNESS_BIAS;
	state.matEmissive = toLinear(state.inEmissive); // linear Space
	state.matOcclusion = state.inOcclusion;
	state.matOpacity = state.inAlbedoAlpha;

	// IBL Calculating
	worldNormalWithTexture = rotateVectorYaw(worldNormalWithTexture, g_IblEnvRotation); // Environment Rotation
	float3 worldReflectVector = normalize(reflect(-WorldView, worldNormalWithTexture));
	float NdotV = abs( dot( worldNormalWithTexture, WorldView ) ) + EPSILON; // Avoid artifact - Ref: SIGGRAPH14 - Moving Frosbite to PBR
	float2 iblBrdf = g_IblBrdfTexture.Sample(SamplerAnisoWrap, float2(NdotV, state.matRoughness)).xyz;
	float3 specColor = state.matSpecColor * iblBrdf.x + iblBrdf.y;;

	state.inSpecularEnv = g_IblSpecTexture.SampleLevel(CubeMapSampler, worldReflectVector.xzy, state.matRoughness * PMREM_MIP_COUNT).xyz; // SpecularEnv Cubemap is already in Linear Space
	state.inDiffuseEnv = g_IblDiffTexture.SampleLevel(CubeMapSampler, worldNormalWithTexture.xzy, 0.0f).xyz * INV_PI; // DiffuseEnv Cubemap is already in Linear Space

	state.iblDiffuse = state.matAlbedo * state.inDiffuseEnv * (1.0 - state.inMetalness) * g_IblDiffScale;
	state.iblSpecular = specColor * state.inSpecularEnv * g_IblSpecScale;
	

	// ---------------------------------------
	// ---------- OUTPUT ---------------------
	// ---------------------------------------
    float3 outColor = float3(1.0, 0.0, 1.0); // pink
	float outAlpha = 1.0;

	bool isDebuggingMaterialInput = false; // Debug Material Input for Paint/Wheel
	float3 tintedDebugColor = float3(1.0, 1.0, 1.0); // white

	// ---------- Debug  & ToneMapping
	if (g_SceneDebugMode == 10) // Debug Checker
	{
		float2 checkerUV = UV0;

		#ifdef _USE_MAP_2_CHANNEL_
			if (g_CheckerUVChannel == 1)
				checkerUV = UV1;
		#endif
		#ifdef _USE_MAP_3_CHANNEL_
			if (g_CheckerUVChannel == 2)
				checkerUV = UV2;
		#endif

		checkerUV *= float2(g_CheckerTilingU, g_CheckerTilingV);

		outColor = g_CheckerTexture.Sample(SamplerAnisoWrap, checkerUV).xyz; // sRGB space
	}

	else if (g_SceneDebugMode == 11) // Debug WorldSpace Nonmal (normal texture applied)
	{
		outColor = vectorToColor(state.matNormal);
	}

	else if (g_SceneDebugMode == 12) // Debug Worldspace VertexNormal
	{
		outColor = vectorToColor(state.vertexNormal);
	}
	else if (g_SceneDebugMode == 13) // Debug WorldSpace VertexTangent
	{
		outColor = vectorToColor(state.vertexTangent);
	}
	else if (g_SceneDebugMode == 14) // Debug WorldSpace VertexBinormal
	{
		outColor = vectorToColor(state.vertexBinormal);
	}

	else if (g_SceneDebugMode == 15) // Debug Raw Albedo
	{
		outColor = state.inAlbedo;
	}
	else if (g_SceneDebugMode == 16) // Debug Raw Alpha
	{
		#ifdef _USE_ALBEDO_ALPHA_FOR_TRANSPARENCY_
			outColor = float3_splat(state.inAlbedoAlpha);
		#else
			discard; // do not render anything
		#endif
	}
	else if (g_SceneDebugMode == 17) // Debug Raw Normal Texture
	{
		outColor = state.inNormal;
	}
	else if (g_SceneDebugMode == 18) // Debug Raw Emissive
	{
		#ifdef _NEED_EMISSIVE_MAP_
			outColor = float3(state.inEmissive);
		#else
			discard; // do not render anything
		#endif
	}
	else if (g_SceneDebugMode == 19) // Debug Raw Occlusion Texture
	{
		outColor = float3_splat(state.inOcclusion);
	}
	else if (g_SceneDebugMode == 20) // Debug Raw Roughness Texture (Surface-Green)
	{
		outColor = float3_splat(state.inRoughness);
	}
	else if (g_SceneDebugMode == 21) // Debug Raw Metalness Texture (Surface-Blue)
	{
		outColor = float3_splat(state.inMetalness);
	}

	else if (g_SceneDebugMode == 23) // Debug Raw Specular Env (sampled from Cubemap)
	{
		outColor = toGamma(state.inSpecularEnv);
	}
	else if (g_SceneDebugMode == 24) // Debug Raw Diffuse Env (sampled from Cubemap)
	{
		outColor = toGamma(state.inDiffuseEnv);
	}

	else if (g_SceneDebugMode == 25) // Debug IBL Spec (use UE4 model)
	{
		outColor = toGamma(state.iblSpecular);
	}
	else if (g_SceneDebugMode == 26) // Debug IBL Diff (use UE4 model)
	{
		outColor = toGamma(state.iblDiffuse);
	}

	else if (g_SceneDebugMode == 40) // Debug Material Input for Paint_Wheel
	{
		#ifdef _PAINT_WHEEL_
			isDebuggingMaterialInput = true;

			if (state.inIor == 64.0f/255.0f) 					//------------ Plastic = 64 RGB
				tintedDebugColor = float3(69.0, 58.0, 56.0) / 255.0;

			else if (state.inIor == 96.0f/255.0f) 				//------------ Vinyl Wrap = 96 RGB
				tintedDebugColor = float3(12.0, 102.0, 68.0) / 255.0;

			else if (state.inIor == 128.0f/255.0f) 				//------------ Single Layer Paint = 128 RGB
				tintedDebugColor = float3(255.0, 102.0, 0.0) / 255.0;

			else if (state.inIor == 160.0f/255.0f) 				//------------ Metallic Paint = 160 RGB
				tintedDebugColor = float3(252.0, 212.0, 38.0) / 255.0;

			else if (state.inIor == 192.0f/255.0f) 				//------------ Carbon Fibre = 192 RGB
				tintedDebugColor = float3(0.1, 0.1, 0.1);

			else if (state.inIor == 96.0f/255.0f) 				//------------ Vinyl Chrome/Foil = 96 RGB
				tintedDebugColor = float3(51.0, 84.0, 144.0) / 255.0;

			else if (state.inIor == 96.0f/255.0f) 				//------------ Rubber = 96 RGB
				tintedDebugColor = float3(51.0, 84.0, 144.0) / 255.0;

			else if (state.inIor == 96.0f/255.0f) 				//------------ Alluminium = 96 RGB
				tintedDebugColor = float3(51.0, 84.0, 144.0) / 255.0;

			else 												//------------ Wrong color
				tintedDebugColor = float3(1.0, 0.0, 1.0); // pink
		#else
			discard;
		#endif
	}


	// DEFAULT: Render Beauty Mode
	if ( (g_SceneDebugMode < 10) || (g_SceneDebugMode == 40) )
	{
		outColor = (state.iblDiffuse + state.iblSpecular) * state.inOcclusion; // HDR color
		#ifdef _PAINT_WHEEL_
			if (g_SceneDebugMode == 40)
				outColor = toLinear(tintedDebugColor) * state.inOcclusion;
		#endif

		#ifdef _NEED_EMISSIVE_MAP_
			state.matEmissive = toLinear(state.inEmissive);
			outColor += state.matEmissive;
		#endif
		outColor *= pow(2.0, g_SceneExposure); // Exposure
		
		outAlpha = state.matOpacity;

		if  (g_SceneToneMappingMethod == 2)
		{	
			// Uncharted2-Filmic Tone Mapping
			outColor = uncharted2Filmic_ToneMapping(outColor);
		}
		else if  (g_SceneToneMappingMethod == 3)
		{
			// Filmic Tone Mapping
			outColor = filmic_ToneMapping(outColor);
		}

		else
		{
			// To Gamma
			outColor = toGamma(outColor); // LDR Color
		}
	}
	
    return float4(outColor, outAlpha);
}



/////////////////// PART IX.    STATES & TECHNIQUES /////////////////////////////
RasterizerState FaceCulling
{
	FillMode = SOLID;
	CullMode = back;
	FrontCounterClockwise = true;
};

RasterizerState FaceCullingWireframe
{
	FillMode = WIREFRAME;
	CullMode = FRONT;
	FrontCounterClockwise = true;
};

RasterizerState NoCulling
{
	FillMode = SOLID;
	CullMode = NONE;

};

DepthStencilState EnableDepth
{
    DepthEnable = TRUE;
	DepthFunc = LESS_EQUAL;
    DepthWriteMask = ALL;
};

BlendState PMAlphaBlending
{
    AlphaToCoverageEnable = FALSE;
	BlendEnable[0] = TRUE;
	SrcBlend = ONE;
	DestBlend = INV_SRC_ALPHA;
	BlendOp = ADD;
	SrcBlendAlpha = ONE;	// Required for hardware frame render alpha channel
	DestBlendAlpha = INV_SRC_ALPHA;
	BlendOpAlpha = ADD;
	RenderTargetWriteMask[0] = 0x0F;
};


fxgroup dx11
{
	technique11 Main_11 <
		string Script = "Pass=p0;";
		#ifdef _USE_ALBEDO_ALPHA_FOR_TRANSPARENCY_
			int isTransparent = 3;
			string transparencyTest = "true";
		#endif
		bool overridesDrawState = false;
	>
	{
		pass p0 <
		string Script = "Draw=geometry;";
		> 
		{
			SetRasterizerState(FaceCulling);
			SetDepthStencilState(EnableDepth, 0);
			// SetDepthStencilState(Depth, 1);
			#ifdef _USE_ALBEDO_ALPHA_FOR_TRANSPARENCY_
				SetBlendState(PMAlphaBlending, float4(0.0f, 0.0f, 0.0f, 0.0f), 0xFFFFFFFF);
			#endif

			SetVertexShader(CompileShader(vs_5_0,std_VS()));
			SetGeometryShader( NULL );
			SetPixelShader(CompileShader(ps_5_0,std_PS()));
		}
	}
}

/////////////////////////////////////// eof //